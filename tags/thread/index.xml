<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thread on TechNotes</title><link>https://ganquan.github.io/tags/thread/</link><description>Recent content in Thread on TechNotes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 21 Nov 2022 22:14:43 +0800</lastBuildDate><atom:link href="https://ganquan.github.io/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>Modern C++ Concurrency 01 - std::thread</title><link>https://ganquan.github.io/modernc++/concurrency-01/</link><pubDate>Mon, 21 Nov 2022 22:14:43 +0800</pubDate><guid>https://ganquan.github.io/modernc++/concurrency-01/</guid><description>现代C++并发编程学习01 - std::thread
std::thread是实现并发编程最基础的工具，使用简单，易于理解。 使用std::thread只需要直接实例化一个std::thread就可以了，可以传入函数，也可以传入lambda
/* 传入函数到线程 */ void foo() { std::cout &amp;lt;&amp;lt; &amp;#34;foo()&amp;#34; &amp;lt;&amp;lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); } std::thread foo_thread(foo); foo_thread.join(); // foo() /* 传入函数到线程，并传入参数 */ void bar(int i) { i += 1; std::cout &amp;lt;&amp;lt; &amp;#34;bar(), i += 1: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(300)); } int i = 2; std::thread bar_thread(bar, i); bar_thread.join(); // bar(), i += 1: 3 /* 传入lambda到线程 */ std::thread lambda_thread([]() { std::cout &amp;lt;&amp;lt; &amp;#34;this is lambda_thread&amp;#34; &amp;lt;&amp;lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); }); lambda_thread.</description></item></channel></rss>