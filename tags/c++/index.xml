<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on TechNotes</title><link>https://ganquan.github.io/tags/c++/</link><description>Recent content in C++ on TechNotes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Nov 2022 09:34:10 +0800</lastBuildDate><atom:link href="https://ganquan.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>Modern C++ Concurrency 01 - std::thread</title><link>https://ganquan.github.io/modernc++/concurrency-01/</link><pubDate>Mon, 21 Nov 2022 22:14:43 +0800</pubDate><guid>https://ganquan.github.io/modernc++/concurrency-01/</guid><description>现代C++并发编程学习01 - std::thread
std::thread是实现并发编程最基础的工具，使用简单，易于理解。 使用std::thread只需要直接实例化一个std::thread就可以了，可以传入函数，也可以传入lambda
/* ========================================================================= */ /* 传入函数到线程 */ void foo() { std::cout &amp;lt;&amp;lt; &amp;#34;foo()&amp;#34; &amp;lt;&amp;lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); } std::thread foo_thread(foo); foo_thread.join(); // foo() /* ========================================================================= */ /* 传入函数到线程，并传入参数 */ void bar(int i) { i += 1; std::cout &amp;lt;&amp;lt; &amp;#34;bar(), i += 1: &amp;#34; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(300)); } int i = 2; std::thread bar_thread(bar, i); bar_thread.join(); // bar(), i += 1: 3 /* ========================================================================= */ /* 传入lambda到线程 */ std::thread lambda_thread([]() { std::cout &amp;lt;&amp;lt; &amp;#34;this is lambda_thread&amp;#34; &amp;lt;&amp;lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); }); lambda_thread.</description></item><item><title>Concurrency 02 - std::future std::promise</title><link>https://ganquan.github.io/modernc++/concurrency-02/</link><pubDate>Tue, 22 Nov 2022 09:34:10 +0800</pubDate><guid>https://ganquan.github.io/modernc++/concurrency-02/</guid><description>上一篇距离说明了std::thread不方便获取线程执行信息，直白的讲，就是线程通信不够方便，所以就引入了std::promise和std::future。
std::promise用于存储异步行为中的信息，std::future用于获取这些信息。 一个也许不是很恰当的理解，可以这么看： std::promise和std::future一起提供了一种单向的线程间通信机制，std::promise是这种通信机制的输入，std::future是这种通信机制的输出。
下面的例子比较直观的说明这种通信：
void bar_promise(std::promise&amp;lt;int&amp;gt; &amp;amp;promise) { std::this_thread::sleep_for(std::chrono::milliseconds(500)); promise.set_value(42); } int main() { std::promise&amp;lt;int&amp;gt; p; std::thread bar_promise_thread(bar_promise, std::ref(p)); bar_promise_thread.join(); auto future = p.get_future(); std::cout &amp;lt;&amp;lt; &amp;#34;future = &amp;#34; &amp;lt;&amp;lt; future.get() &amp;lt;&amp;lt; std::endl; // future == 42 return 0; } future.get()会阻塞等待promise的值准备好：
/* future.get() 会阻塞等待直到future有值 */ int main() { std::promise&amp;lt;int&amp;gt; p; std::thread bar_promise_thread(bar_promise, std::ref(p)); bar_promise_thread.detach(); /* bar_promise_thread.join(); */ std::future&amp;lt;int&amp;gt; future = p.get_future(); std::cout &amp;lt;&amp;lt; &amp;#34;future = &amp;#34; &amp;lt;&amp;lt; future.get() &amp;lt;&amp;lt; std::endl; // future == 42 return 0; } 如果在线程中没有调用promise的set_value，那么在调用future.</description></item></channel></rss>