<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Future on TechNotes</title><link>https://ganquan.github.io/tags/future/</link><description>Recent content in Future on TechNotes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Nov 2022 09:34:10 +0800</lastBuildDate><atom:link href="https://ganquan.github.io/tags/future/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency 02 - std::future std::promise</title><link>https://ganquan.github.io/modernc++/concurrency-02/</link><pubDate>Tue, 22 Nov 2022 09:34:10 +0800</pubDate><guid>https://ganquan.github.io/modernc++/concurrency-02/</guid><description>上一篇距离说明了std::thread不方便获取线程执行信息，直白的讲，就是线程通信不够方便，所以就引入了std::promise和std::future。
std::promise用于存储异步行为中的信息，std::future用于获取这些信息。 一个也许不是很恰当的理解，可以这么看： std::promise和std::future一起提供了一种单向的线程间通信机制，std::promise是这种通信机制的输入，std::future是这种通信机制的输出。
下面的例子比较直观的说明这种通信：
void bar_promise(std::promise&amp;lt;int&amp;gt; &amp;amp;promise) { std::this_thread::sleep_for(std::chrono::milliseconds(500)); promise.set_value(42); } int main() { std::promise&amp;lt;int&amp;gt; p; std::thread bar_promise_thread(bar_promise, std::ref(p)); bar_promise_thread.join(); auto future = p.get_future(); std::cout &amp;lt;&amp;lt; &amp;#34;future = &amp;#34; &amp;lt;&amp;lt; future.get() &amp;lt;&amp;lt; std::endl; // future == 42 return 0; } future.get()会阻塞等待promise的值准备好：
/* future.get() 会阻塞等待直到future有值 */ int main() { std::promise&amp;lt;int&amp;gt; p; std::thread bar_promise_thread(bar_promise, std::ref(p)); bar_promise_thread.detach(); /* bar_promise_thread.join(); */ std::future&amp;lt;int&amp;gt; future = p.get_future(); std::cout &amp;lt;&amp;lt; &amp;#34;future = &amp;#34; &amp;lt;&amp;lt; future.get() &amp;lt;&amp;lt; std::endl; // future == 42 return 0; } 如果在线程中没有调用promise的set_value，那么在调用future.</description></item></channel></rss>