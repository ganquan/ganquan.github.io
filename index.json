[{"uri":"https://ganquan.github.io/modernc++/","title":"Modern C++","tags":[],"description":"","content":"Chapter X 一些学习Modern C++的记录 还是C++有意思啊\n"},{"uri":"https://ganquan.github.io/neovim/","title":"Neovim","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://ganquan.github.io/","title":"","tags":[],"description":"","content":"轻量C/C++开发环境Neovim配置\n"},{"uri":"https://ganquan.github.io/tags/c++/","title":"C++","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/concurrency/","title":"Concurrency","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/modernc++/concurrency-01/","title":"Modern C++ Concurrency 01 - std::thread","tags":["C++","Concurrency","Note","Thread"],"description":"","content":"现代C++并发编程学习01 - std::thread\nstd::thread是实现并发编程最基础的工具，使用简单，易于理解。 使用std::thread只需要直接实例化一个std::thread就可以了，可以传入函数，也可以传入lambda\n/* 传入函数到线程 */ void foo() { std::cout \u0026lt;\u0026lt; \u0026#34;foo()\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); } std::thread foo_thread(foo); foo_thread.join(); // foo() /* 传入函数到线程，并传入参数 */ void bar(int i) { i += 1; std::cout \u0026lt;\u0026lt; \u0026#34;bar(), i += 1: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(300)); } int i = 2; std::thread bar_thread(bar, i); bar_thread.join(); // bar(), i += 1: 3 /* 传入lambda到线程 */ std::thread lambda_thread([]() { std::cout \u0026lt;\u0026lt; \u0026#34;this is lambda_thread\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); }); lambda_thread.join(); //this is lambda_thread 只需要在线程对象调用join()方法，就可以等待线程执行结果。如果不调用join()，则是未定义行为。 即，线程对象的持有者可能先于线程结束。\nstd::thread虽然简单，但是并不常用，一个最直接的问题是，我们需要把一些过程放到线程上异步执行，但是又希望得到执行结果。 例如开一个线程执行计算，需要获取计算结果。 使用std::thread并不能直接返回计算结果，一个可以尝试的方法是，传入引用，利用引用机制从参数返回结果。\nint j = 4; /* 注意参数是引用类型 */ void bar_ref(int \u0026amp;i) { i += 1; std::cout \u0026lt;\u0026lt; \u0026#34;bar_ref(), i += 1: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(100)); } /* 构造线程对象，传入函数方式不变，传入引用类型参数需要使用std::ref */ std::thread bar_ref_thread(bar_ref, std::ref(j)); bar_ref_thread.join(); std::cout \u0026lt;\u0026lt; \u0026#34;j = \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; std::endl; // j = 5 虽然可以实现获取线程执行结果的返回值，但是这样并不方便使用。 std::thread也不是没用，不然在C++11之后的各个版本里面就会废弃掉。最多用到的场景是：线程池。\n关于线程池，放到后面再说。\n"},{"uri":"https://ganquan.github.io/tags/note/","title":"Note","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/thread/","title":"Thread","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/neovim/first-content/","title":"First Content","tags":["tutorial","neovim"],"description":"","content":"This is Neovim first content.\n"},{"uri":"https://ganquan.github.io/tags/neovim/","title":"neovim","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/tutorial/","title":"tutorial","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/categories/","title":"Categories","tags":[],"description":"","content":""}]