[{"uri":"https://ganquan.github.io/modernc++/","title":"Modern C++","tags":[],"description":"","content":"目录 Modern C++ 并发编程 现代C++并发 01 std::thread 现代C++并发 02 std::future std::promise 现代C++并发 03 std::async "},{"uri":"https://ganquan.github.io/neovim/","title":"Neovim","tags":[],"description":"","content":"Chapter X Some Chapter title Lorem Ipsum.\n"},{"uri":"https://ganquan.github.io/modernc++/concurrency-01/","title":"Modern C++ Concurrency 01 - std::thread","tags":["C++","Concurrency","Note","Thread"],"description":"","content":"现代C++并发编程学习01 - std::thread\nstd::thread是实现并发编程最基础的工具，使用简单，易于理解。 使用std::thread只需要直接实例化一个std::thread就可以了，可以传入函数，也可以传入lambda\n/* ========================================================================= */ /* 传入函数到线程 */ void foo() { std::cout \u0026lt;\u0026lt; \u0026#34;foo()\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); } std::thread foo_thread(foo); foo_thread.join(); // foo() /* ========================================================================= */ /* 传入函数到线程，并传入参数 */ void bar(int i) { i += 1; std::cout \u0026lt;\u0026lt; \u0026#34;bar(), i += 1: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(300)); } int i = 2; std::thread bar_thread(bar, i); bar_thread.join(); // bar(), i += 1: 3 /* ========================================================================= */ /* 传入lambda到线程 */ std::thread lambda_thread([]() { std::cout \u0026lt;\u0026lt; \u0026#34;this is lambda_thread\u0026#34; \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(20)); }); lambda_thread.join(); //this is lambda_thread 只需要在线程对象调用join()方法，就可以等待线程执行结果。如果不调用join()，则是未定义行为。 即，线程对象的持有者可能先于线程结束。\nstd::thread虽然简单，但是并不常用，一个最直接的问题是，我们需要把一些过程放到线程上异步执行，但是又希望得到执行结果。 例如开一个线程执行计算，需要获取计算结果。 使用std::thread并不能直接返回计算结果，一个可以尝试的方法是，传入引用，利用引用机制从参数返回结果。\nint j = 4; /* 注意参数是引用类型 */ void bar_ref(int \u0026amp;i) { i += 1; std::cout \u0026lt;\u0026lt; \u0026#34;bar_ref(), i += 1: \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; std::this_thread::sleep_for(std::chrono::milliseconds(100)); } /* 构造线程对象，传入函数方式不变，传入引用类型参数需要使用std::ref */ std::thread bar_ref_thread(bar_ref, std::ref(j)); bar_ref_thread.join(); std::cout \u0026lt;\u0026lt; \u0026#34;j = \u0026#34; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; std::endl; // j = 5 虽然可以实现获取线程执行结果的返回值，但是这样并不方便使用。 std::thread也不是没用，不然在C++11之后的各个版本里面就会废弃掉。最多用到的场景是：线程池。\n关于线程池，放到后面再说。\n"},{"uri":"https://ganquan.github.io/modernc++/concurrency-02/","title":"Concurrency 02 - std::future std::promise","tags":["C++","Concurrency","Note","Thread","Promise","Future"],"description":"","content":"上一篇举例说明了std::thread不方便获取线程执行信息，直白的讲，就是线程通信不够方便，所以就引入了std::promise和std::future。\nstd::promise用于存储异步行为中的信息，std::future用于获取这些信息。 一个也许不是很恰当的理解，可以这么看： std::promise和std::future一起提供了一种单向的线程间通信机制，std::promise是这种通信机制的输入，std::future是这种通信机制的输出。\n下面的例子比较直观的说明这种通信：\nvoid bar_promise(std::promise\u0026lt;int\u0026gt; \u0026amp;promise) { std::this_thread::sleep_for(std::chrono::milliseconds(500)); promise.set_value(42); } int main() { std::promise\u0026lt;int\u0026gt; p; std::thread bar_promise_thread(bar_promise, std::ref(p)); bar_promise_thread.join(); auto future = p.get_future(); std::cout \u0026lt;\u0026lt; \u0026#34;future = \u0026#34; \u0026lt;\u0026lt; future.get() \u0026lt;\u0026lt; std::endl; // future == 42 return 0; } future.get()会阻塞等待promise的值准备好：\n/* future.get() 会阻塞等待直到future有值 */ int main() { std::promise\u0026lt;int\u0026gt; p; std::thread bar_promise_thread(bar_promise, std::ref(p)); bar_promise_thread.detach(); /* bar_promise_thread.join(); */ std::future\u0026lt;int\u0026gt; future = p.get_future(); std::cout \u0026lt;\u0026lt; \u0026#34;future = \u0026#34; \u0026lt;\u0026lt; future.get() \u0026lt;\u0026lt; std::endl; // future == 42 return 0; } 如果在线程中没有调用promise的set_value，那么在调用future.get()方法时，就会一直阻塞住调用者。\n到这里来看，std::promise和std::future机制，在书写上，也没有比通过引用获取值的方式要简化多少。\n但是Modern C++提供了另外一个工具，来更进一步方便这种通信方式的书写，就是std::packaged_task。 语言手册的解释是，std::packaged_task封装了任意的可调用(Callable)对象以异步执行，例如function、lambda、 bind expression以及其他函数对象。 std::packaged_task提供了get_future方法用于获取异步执行的结果。\n到这里一个对比和总结就显现出来了，即：\nstd::promise和std::packaged_task都提供get_future方法，但是std::promise只是对数据的封装，而std::packaged_task则实现了对异步过程的封装。\n所以，std::packaged_task的抽象程度，一下子就脱离了基础的promise和future，在抽象层次上更高了。\n看下面这个例子：\nint main() { std::packaged_task\u0026lt;int(int, int)\u0026gt; task([](int a, int b) { std::this_thread::sleep_for(std::chrono::milliseconds(500)); return a + b; }); auto future_task = task.get_future(); task(5, 8); std::cout \u0026lt;\u0026lt; \u0026#34;future = \u0026#34; \u0026lt;\u0026lt; future_task.get() \u0026lt;\u0026lt; std::endl; //future = 13 return 0; } 没有了std::promise相关的代码，书写上就变得简洁不少。\n"},{"uri":"https://ganquan.github.io/modernc++/concurrency-03/","title":"Concurrency 03 - std::async","tags":["C++","Concurrency","Note","Thread","Promise","Future","async"],"description":"","content":"之前两篇写了C++11并发编程基础工具中的std::thread、std::promise、std::future、std::packaged_task做了简单的介绍。 这一篇写std::async，这个是另外一种工具。\n"},{"uri":"https://ganquan.github.io/","title":"","tags":[],"description":"","content":" Neovim配置轻量级C/C++开发环境 Modern C++并发学习笔记 "},{"uri":"https://ganquan.github.io/tags/async/","title":"async","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/c++/","title":"C++","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/concurrency/","title":"Concurrency","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/future/","title":"Future","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/note/","title":"Note","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/promise/","title":"Promise","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/","title":"Tags","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/thread/","title":"Thread","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/neovim/first-content/","title":"First Content","tags":["tutorial","neovim"],"description":"","content":"This is Neovim first content.\n"},{"uri":"https://ganquan.github.io/tags/neovim/","title":"neovim","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/tags/tutorial/","title":"tutorial","tags":[],"description":"","content":""},{"uri":"https://ganquan.github.io/categories/","title":"Categories","tags":[],"description":"","content":""}]